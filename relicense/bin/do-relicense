#!/usr/bin/perl -w
use strict;

my $DEBUG = $ENV{DEBUG} // 0;
my $FORCE = $ENV{FORCE} // 0;
use Data::Dumper;

use JSON::XS;
use LWP::UserAgent;
use HTML::TreeBuilder::XPath;

use File::Spec;
use File::Basename;
use FindBin;
use Cwd;

my $initial_cwd = $ENV{PWD};

my $json = JSON::XS->new->utf8->pretty;
my $ua = LWP::UserAgent->new;

my $allseen_copyright_start = 'Copyright AllSeen Alliance. All rights reserved.';
my $allseen_copyright_end = 'OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.';

my $new_copyright = 'Copyright (c) 2016 Open Connectivity Foundation and AllJoyn Open Source Project Contributors and others.';

my $allseen_license_rx = qr{(${allseen_copyright_start}.*${allseen_copyright_end})}ms;

my $xpath_query =
  {
   commit_info_date    => q{//table[@class="commit-info"]//tr[1]/td[@class="right"]},
   commit_info_subject => q{//div[@class="commit-subject"]},
  };

my $domain = q{allseenalliance.org};

my $gerrit_host = qq{git.$domain};
my $gerrit_port = 29418;

my $git_host = qq{cgit.$domain};

my( %project );

# Exceptions to filter out projects known not to be updating licenses can go here.
my $proj_skip_rx = qr{
                       (
                         ^All-Users$ |
                         ^$
                       )
                   }x;

my $scriptname    = $FindBin::Script;
my $scriptdirname = $FindBin::Bin;

my $temp_dir = qq{/tmp/${scriptname}};

system(qq{rm -rf ${temp_dir}}) if $FORCE;
system(qq{mkdir -p ${temp_dir}});

my $repo_data_json_file = qq{${temp_dir}/alljoyn-repos-data.json};

sub save_repo_data {
  my( $project ) = @_;

  # remove projects with no branches
  foreach my $pname ( keys %$project ){
    if( scalar( keys %{$project->{$pname}->{branch}} ) == 0 ){
      delete $project->{$pname};
    }
  }

  my $json_str = $json->encode( $project );
  open( my($json_fh), q{>}, $repo_data_json_file )
    or die "couldn't open json file [$repo_data_json_file]: $!";

  print $json_fh $json_str;
}

my $template_file = Cwd::abs_path( File::Spec->catfile($scriptdirname, '..', 'template', 'new_license.txt') );
my $commit_template_file = Cwd::abs_path( File::Spec->catfile($scriptdirname, '..', 'template', 'commit-message.txt') );
my $license_file = Cwd::abs_path( File::Spec->catfile($scriptdirname, '..', 'template', 'LICENSE-2.0' ) );
my $license_file_basename = basename $license_file;

if( -f $repo_data_json_file ){
  my $json_str = do {
    open( my( $json_fh ), q{<}, $repo_data_json_file )
      or die "couldn't open json file $repo_data_json_file: $!";

    my @line = (<$json_fh>);
    join($/,@line);
  };
  %project = %{ $json->decode( $json_str ) };
}else{

  my $json_str = qx{ssh -p ${gerrit_port} ${gerrit_host} gerrit ls-projects --format=JSON};
  my $project = $json->decode( $json_str );
  my @project = keys %$project;

  foreach my $pname ( @project ){
    next if( $pname =~ /$proj_skip_rx/ );
    next if( $project->{$pname}->{state} eq 'READ_ONLY' );

    my %branch;

    $project{$pname} = { name => $pname,
                        branch => \%branch,
                      };

    print ("Project: [$pname]\n");

    my $gerrit_url = qq{ssh://${gerrit_host}:${gerrit_port}/${pname}};

    my $cgit_url = qq{https://${git_host}/${pname}.git};

    my @remote = split(/\n/, qx{git ls-remote --heads $gerrit_url 2>/dev/null});
    foreach my $remote (@remote){
      my($commit_id,$headname) = split(/\s+/, $remote);

      my($branch_name) = ($headname =~ m{refs/heads/(.+)});

      next if( $branch_name =~ /_re-license$/ ||
               $branch_name =~ /^feature/
               );

      print ("  Branch: [$branch_name]\n");

      my $branch = {
                    id => $commit_id,
                    name => $branch_name,
                    date => undef,
                    subject => undef,
                   };

      my $url = "$cgit_url/commit/?id=${commit_id}";

      my $response = $ua->get($url);

      my $content = $response->decoded_content;

      my $tree = HTML::TreeBuilder::XPath->new;
      $tree->parse($content);
      $tree->eof;

      # Check for error
      my @error_element = $tree->findnodes( q{//*[@id="cgit"]/div[@class="content"]/div[@class="error"]} );

      if( @error_element ){
        print STDERR qq{Error with branch: $error_element[0]->content_array_ref->[0]\n};
        next;
      }

      # extract date
      $branch->{date} = $tree->findnodes( $xpath_query->{commit_info_date} )->[0]->content_array_ref->[0];

      # extract subject
      $branch->{subject} = $tree->findnodes( $xpath_query->{commit_info_subject} )->[0]->content_array_ref->[0];

      $tree = $tree->delete;

      next if( $branch->{subject} eq 'Initial empty repository' );

      print STDERR qq{  Subject string: [$branch->{subject}] [$branch->{date}]\n} if $DEBUG;

      $branch{$branch_name} = $branch;
    }
  }

  save_repo_data( \%project );
}


open( my( $template_fh ), q{<}, $template_file )
  or die "couldn't open template file $template_file: $!";

my( @template_line ) = <$template_fh>;
chomp( @template_line );

close( $template_fh );

my $num_projects = scalar keys %project;

print STDERR qq{Updating licenses in $num_projects projects\n};

my $max_proj_name_len = 0;
my $max_branch_name_len = 0;

foreach my $pname ( keys %project ){
  my $p = $project{$pname};
  foreach my $bname ( keys %{$p->{branch}} ){
    next unless length( $bname ) > $max_branch_name_len;
    $max_branch_name_len = length( $bname );
  }
  next unless length( $pname ) > $max_proj_name_len;
  $max_proj_name_len = length( $pname );
}

sub checkout_branch {
  my( $bname ) = @_;

  # Check out the branch from the gerrit remote
  my $git_cmd = qq(git checkout -B ${bname} -qt remotes/gerrit/${bname});
  my $git_output = qx($git_cmd 2>&1);

  # Make sure we're on the correct revision on the gerrit remote
  chomp( my( $last_gerrit_commit ) = qx(git log --format="%H" -n 1 gerrit/${bname}) );
  system(qq{git reset --hard ${last_gerrit_commit} > /dev/null 2>&1});

  # remove extra files
  $git_cmd = qq(git ls-files --others --exclude-standard);
  $git_output = qx($git_cmd);
  my @extra_files = split($/, $git_output);
  unlink @extra_files;
}

sub checkout_topic {
  my( $bname, $gerrit_change ) = @_;

  # Create the topic branch by default
  my( $mode, $git_cmd ) =
    ('create', qq(git checkout -q -b ${bname}_re-license) );

  if ( ref $gerrit_change && exists $gerrit_change->{number} ) {
    # Die unless the topic branch subject matches
    unless( $gerrit_change->{subject} =~ /Apache License Version 2.0/ms ){
      die "gerrit change is not re-license";
    }

    # Check out the topic branch if a 
    $git_cmd = qq(git review -d $gerrit_change->{number});

    $mode = 'amend';
  }

  # create / checkout topic branch
  my $git_output = qx($git_cmd 2>&1);

  return $mode;

}

sub update_file {
  my( $fname, $mode, $bname ) = @_;

  if ( $mode eq 'amend' ) {
    # Check out the original version of the file
    my $git_cmd = qq{git checkout ${bname} '${fname}'};
    my $git_output = qx($git_cmd);
  }

  open( my( $fh ), q{<}, $fname ) or die "couldn't open file ${fname}: $!";
  chomp( my @lines = <$fh> );
  close $fh;

  my $content = join($/, @lines);

  my( $comment_prefix, $line_prefix, $comment_suffix );

  my( $license_start_line ) = grep { /$allseen_copyright_start/ } @lines;
  my( $license_end_line ) = grep { /$allseen_copyright_end/ } @lines;

  unless( $license_start_line ){
    print STDERR "Filename: $fname\n";
    die "bad file";
  }

  if ( defined $license_end_line && $license_start_line eq $license_end_line ) {
    my $new_license = join(' ', @template_line);
    $content =~ s{$allseen_license_rx}{$new_license}ms;

  } elsif ( $license_end_line ) {
    # extract comment prefix, line prefix and comment suffix in use for this file
    my( $start_prefix, $start, $start_suffix ) =
      ( $license_start_line =~ /^(.*)($allseen_copyright_start)(.*)$/ );

    my( $end_prefix, $end, $end_suffix ) =
      ( $license_end_line =~ /^(.*)($allseen_copyright_end)(.*)$/ );

    $comment_prefix = $start_prefix;
    if ( defined $start_prefix && $start_prefix eq $end_prefix ) {
      $line_prefix = $start_prefix;
    } else {
      $line_prefix = $end_prefix;
      $comment_suffix = $end_suffix;
    }

    my( $old_license ) = ( $content =~ m{$allseen_license_rx} );

    my @new_license = (
                       defined $comment_prefix ? $comment_prefix : (),
                       ( map { "${line_prefix}$_" } @template_line ),
                       defined $comment_suffix ? $comment_suffix : (),
                      );

    my $new_license = join("\n", @new_license);

    # replace old license with new text
    $content =~ s{$allseen_license_rx}{$new_license}ms;

  } else {
    $content =~ s{$allseen_copyright_start}{$new_copyright}ms;
  }

  open( $fh, q{>}, $fname ) or die "couldn't open file ${fname} for writing: $!";
  print $fh $content;
  close $fh;

  system( qq{git add '$fname'} );
}

my $file_match_fmt = q{  Branch %2i/%i %*s: %4i/%-4i files contain AllSeen copyright.  };

my $pnum = 0;
foreach my $pname ( sort keys %project ){
  $pnum++;
  if( $pname =~ m{^(.+)/([^/]+)$} ){
    my $dir = qq{${temp_dir}/$1};
    system(qq{mkdir -p $dir});
    chdir( $dir );
  }else{
    chdir( $temp_dir );
  }
  my $p = $project{$pname};
  my $num_branches = scalar keys %{$p->{branch}};

  next unless $num_branches > 0;

  my $gerrit_url = qq{ssh://${gerrit_host}:${gerrit_port}/${pname}};

  my $pdir = qq{${temp_dir}/${pname}};

#  system(qq{rm -rf ${pdir}}); # TODO: remove this

  my $git_output = qx(git clone -q $gerrit_url 2>/dev/null) unless -d $pdir;
  chdir( $pdir );

  my $rebase_dir = '.git/rebase-merge';
  if( -d $rebase_dir ){
    system("rm -rf $rebase_dir");
  }

  if( qx{git remote get-url gerrit 2>&1} =~ /^fatal/ ){
    system(qq(git remote add gerrit $gerrit_url));
  }else{
    system(qq(git remote set-url gerrit $gerrit_url));
  }

  $git_output = qx{git fetch gerrit 2>&1};

  die "couldn't fetch gerrit remote: [$?] [$git_output]" unless $? == 0;

  my $git_branches = qx(git branch -a);

  print STDERR "\n", sprintf( q{Project %2i/%i %*s: %2i branch(es)}, $pnum, $num_projects, $max_proj_name_len, $pname, $num_branches ), "\n";
  my $bnum = 0;
  foreach my $bname ( sort keys %{$p->{branch}} ){
    $bnum++;

    checkout_branch( $bname );
    # find all files
    my @all_files = split($/, qx{find . -type f -a -not -name '.git'});
    my $num_files = scalar @all_files;

    # find files with old license
    my @matching_files = split($/, qx(grep -rsil '${allseen_copyright_start}' .));
    my $num_matching_files = scalar @matching_files;

    # find files without old license
    my @unmatching_files = split($/, qx(grep -rsiL '${allseen_copyright_start}' .));
    my $num_unmatching_files = scalar @unmatching_files;

    # Query gerrit for a topic
    my $topic_name = "${bname}_re-license";
    my $gerrit_cmd = qq{ssh -p ${gerrit_port} ${gerrit_host} gerrit query --format=JSON project:${pname} topic:${topic_name}};
    my( $change_json ) = qx{$gerrit_cmd};
    my $gerrit_change = $json->decode( $change_json );

    my $file_stats = sprintf($file_match_fmt,
                             $bnum, $num_branches,
                             $max_branch_name_len, $bname,
                             $num_matching_files, $num_files
                            );

    if( $num_matching_files == 0 ){
      print STDERR ( $file_stats, "Skipping.\n" );

      # Remove this branch from the %project hash
      delete $project{$pname}->{branch}->{$bname};

      # There should not be a change number in the case that there are
      # 0 changed files.  If we erroneously created one, abandon.
      if( ref $gerrit_change && exists $gerrit_change->{number} ){

        my $ref_fname = ".git/refs/heads/${topic_name}";
        unlink $ref_fname if( -f $ref_fname );
        print STDERR ( qq{ssh -p ${gerrit_port} ${gerrit_host} gerrit review --abandon $gerrit_change->{number}}, "\n");
      }

      # save project JSON so we don't use this branch next pass.
      save_repo_data( \%project );

      next;
    }

    my $change_num = $gerrit_change->{number};
    my $change_id = $gerrit_change->{id};

    my $mode = checkout_topic( $bname, $gerrit_change );
    print STDERR ( $file_stats, "Updating" );

    my $i = 0;
    my $tenth = int( $num_matching_files / 10 );
    $tenth = 1 if $tenth < 2;
    foreach my $fname ( @matching_files ){
      update_file( $fname, $mode, $bname );
      print STDERR '.' if $i++ % $tenth == 0 && $DEBUG;
    }
    print STDERR "\n" if $DEBUG;

    system( qq(cp $license_file .) );
    system( qq(git add $license_file_basename) );

    @matching_files = split(/\n/, qx(grep -rsil '${allseen_copyright_start}' .));

    $num_matching_files = scalar @matching_files;

    if( $num_matching_files > 0 ){
      print STDERR ( "files still contain copyright!\n",
                     join("\n", @matching_files),
                     "\n"
                   ) if $DEBUG;

      exit 1;
    }

    my $commit_msg = "-F $commit_template_file" . ($mode eq 'amend' ? ' --amend' : '');

    # commit or amend signed change
    system( "git commit -q -s $commit_msg" );

    # who's on first
    open( my( $dotgitreview_fh ), q{>}, '.gitreview' )
      or die 'could not open .gitreview for writing';

    print $dotgitreview_fh <<"EOF";
[gerrit]
host=git.allseenalliance.org
port=29418
project=${pname}
defaultbranch=${bname}
EOF

    # submit to gerrit
#    my $git_output = qx{git review};
#    if( $git_output =~ /error/i ){
#      die $git_output;
#    }
  }
}

END {
  chdir( $initial_cwd );
}
